#!/usr/bin/env python
# Copyright Joyent, Inc. and other Node contributors. All rights reserved.
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import optparse
import os
import pprint
import re
import shlex
import subprocess
import sys

CC = os.environ.get('CC', 'cc')

root_dir = os.path.dirname(__file__)
sys.path.insert(0, os.path.join(root_dir, 'deps', 'v8', 'tools'))

# parse our options
parser = optparse.OptionParser()

parser.add_option("--debug",
    action="store_true",
    dest="debug",
    help="Build debug version")

(options, args) = parser.parse_args()


def cc_macros():
  """Checks predefined macros using the CC command."""

  try:
    p = subprocess.Popen(shlex.split(CC) + ['-dM', '-E', '-'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
  except OSError:
    print '''configure error: No acceptable C compiler found!

        Please make sure you have a C compiler installed on your system and/or
        consider adjusting the CC environment variable if you installed
        it in a non-standard prefix.
        '''
    sys.exit()

  p.stdin.write('\n')
  out = p.communicate()[0]

  out = str(out).split('\n')

  k = {}
  for line in out:
    lst = shlex.split(line)
    if len(lst) > 2:
      key = lst[1]
      val = lst[2]
      k[key] = val
  return k


def host_arch_cc():
  """Host architecture check using the CC command."""

  k = cc_macros()

  matchup = {
    '__x86_64__'  : 'x64',
    '__i386__'    : 'ia32',
    '__arm__'     : 'arm',
  }

  rtn = 'ia32' # default

  for i in matchup:
    if i in k and k[i] != '0':
      rtn = matchup[i]
      break

  return rtn


def host_arch_win():
  """Host architecture check using environ vars (better way to do this?)"""

  arch = os.environ.get('PROCESSOR_ARCHITECTURE', 'x86')

  matchup = {
    'AMD64'  : 'x64',
    'x86'    : 'ia32',
    'arm'    : 'arm',
  }

  return matchup.get(arch, 'ia32')


def configure(o):
  o['default_configuration'] = 'Debug' if options.debug else 'Release'

  arch = host_arch_win() if os.name == 'nt' else host_arch_cc()
  o['variables']['host_arch']   = arch
  o['variables']['target_arch'] = arch


output = {
  'variables': {},
  'include_dirs': [],
  'libraries': [],
  'defines': [],
  'cflags': [],
}

configure(output)

# variables should be a root level element,
# move everything else to target_defaults
variables = output['variables']
del output['variables']
output = {
  'variables': variables,
  'target_defaults': output
}
pprint.pprint(output, indent=2)

def write(filename, data):
  filename = os.path.join(root_dir, filename)
  print "creating ", filename
  f = open(filename, 'w+')
  f.write(data)

write('config.gypi', "# Do not edit. Generated by the configure script.\n" +
  pprint.pformat(output, indent=2) + "\n")

config = {
  'BUILDTYPE':   'Debug' if options.debug else 'Release'
}
config = '\n'.join(map('='.join, config.iteritems())) + '\n'

write('config.mk',
      '# Do not edit. Generated by the configure script.\n' + config)

gyp_args = ['-f', 'make']

subprocess.call([sys.executable, 'tools/gyp_server'] + gyp_args)

